package main

import (
	"encoding/hex"
	"fmt"
	"path/filepath"
	"strconv"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/backend/plonk"
	native_plonk "github.com/consensys/gnark/backend/plonk"
	"github.com/consensys/gnark/backend/witness"
	"github.com/consensys/gnark/constraint"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/std/algebra/emulated/sw_bn254"
	recursive_plonk "github.com/consensys/gnark/std/recursion/plonk"
	"github.com/lightec-xyz/chainark"
	"github.com/lightec-xyz/chainark/example/common"
	"github.com/lightec-xyz/common/operations"
	common_utils "github.com/lightec-xyz/common/utils"
)

/**
 * this circuit is used prove that an inner proof has been verified, and that its beginId and endId are as expected,
 * and that the inner proof had been generated by one of the recognized circuits.
**/
type RecursiveVerifier struct {
	*chainark.Verifier[sw_bn254.ScalarField, sw_bn254.G1Affine, sw_bn254.G2Affine, sw_bn254.GTEl]
	BeginID chainark.LinkageID //`gnark:",public"`
	EndID   chainark.LinkageID //`gnark:",public"`
}

func (c *RecursiveVerifier) Define(api frontend.API) error {
	err := c.Verifier.Define(api)
	if err != nil {
		return nil
	}

	nbIdVars := len(c.BeginID.Vals)
	chainark.AssertIDWitness[sw_bn254.ScalarField](api, c.BeginID, c.Verifier.Witness.Public[0:nbIdVars])
	chainark.AssertIDWitness[sw_bn254.ScalarField](api, c.EndID, c.Verifier.Witness.Public[nbIdVars:nbIdVars*2])
	return nil
}

func NewRecursiveVerifierCircuit(
	ccs constraint.ConstraintSystem,
	vkeyFpsBytes []common_utils.FingerPrintBytes,
	nbIdVars, nbFpVars, nbSelfFps int,
) (*RecursiveVerifier, error) {
	v, err := chainark.NewVerifierCircuit[sw_bn254.ScalarField, sw_bn254.G1Affine, sw_bn254.G2Affine, sw_bn254.GTEl](
		ccs, vkeyFpsBytes, nbIdVars, nbFpVars, nbSelfFps,
	)
	if err != nil {
		return nil, err
	}
	return &RecursiveVerifier{
		Verifier: v,
		BeginID:  chainark.PlaceholderLinkageID(common.NbIDVals, common.NbBitsPerIDVal),
		EndID:    chainark.PlaceholderLinkageID(common.NbIDVals, common.NbBitsPerIDVal),
	}, nil
}

func NewRecursiveVerifierAssignment(beginId, endId chainark.LinkageID,
	vkey native_plonk.VerifyingKey,
	proof native_plonk.Proof,
	witness witness.Witness,
) (*RecursiveVerifier, error) {
	v, err := chainark.NewVerifierAssignment[sw_bn254.ScalarField, sw_bn254.G1Affine, sw_bn254.G2Affine, sw_bn254.GTEl](
		vkey, proof, witness,
	)
	if err != nil {
		return nil, err
	}
	return &RecursiveVerifier{
		Verifier: v,
		BeginID:  beginId,
		EndID:    endId,
	}, nil
}

func verify(args []string) {
	l := common.NbIDVals * common.NbBitsPerIDVal * 2 / 8
	if len(args) != 7 {
		panic("expected 7 parameters")
	}

	//load vk
	innerVk, err := operations.ReadVk(filepath.Join(dataDir, args[0]))
	if err != nil {
		panic(err)
	}

	//load proof&witness
	innerProof, err := operations.ReadProof(filepath.Join(dataDir, args[1]))
	if err != nil {
		panic(err)
	}
	innerWitness, err := operations.ReadWitness(filepath.Join(dataDir, args[2]))
	if err != nil {
		panic(err)
	}

	beginHex := args[3]
	endHex := args[4]

	if len(beginHex) != l || len(endHex) != l {
		panic("expected 32 bytes")
	}

	beginID, err := hex.DecodeString(beginHex)
	if err != nil {
		panic(err)
	}

	endID, err := hex.DecodeString(endHex)
	if err != nil {
		panic(err)
	}

	beignIndex, err := strconv.ParseInt(args[5], 10, 32)
	if err != nil {
		panic(err)
	}

	endIndex, err := strconv.ParseInt(args[6], 10, 32)
	if err != nil {
		panic(err)
	}

	nbIDs := int(endIndex - beignIndex)
	println("total ids in the proof", nbIDs)

	assignment, err := NewRecursiveVerifierAssignment(
		chainark.LinkageIDFromBytes(beginID, common.NbBitsPerIDVal),
		chainark.LinkageIDFromBytes(endID, common.NbBitsPerIDVal),
		innerVk, innerProof, innerWitness,
	)

	witness, err := frontend.NewWitness(assignment, ecc.BN254.ScalarField())
	if err != nil {
		panic(err)
	}
	pubWitness, err := witness.Public()
	if err != nil {
		panic(err)
	}

	fmt.Println("loading ccs, pk, vk ...")
	ccs, err := operations.ReadCcs(filepath.Join(dataDir, common.VerifierCcsFile))
	if err != nil {
		panic(err)
	}

	pk, err := operations.ReadPk(filepath.Join(dataDir, common.VerifierPkFile))
	if err != nil {
		panic(err)
	}

	vk, err := operations.ReadVk(filepath.Join(dataDir, common.VerifierVkFile))
	if err != nil {
		panic(err)
	}

	fmt.Println("proving ...")
	proof, err := plonk.Prove(ccs, pk, witness,
		recursive_plonk.GetNativeProverOptions(ecc.BN254.ScalarField(), ecc.BN254.ScalarField()))
	if err != nil {
		panic(err)
	}

	fmt.Println("verifying ...")
	err = plonk.Verify(proof, vk, pubWitness,
		recursive_plonk.GetNativeVerifierOptions(ecc.BN254.ScalarField(), ecc.BN254.ScalarField()))
	if err != nil {
		panic(err)
	}

	fmt.Println("saving proof and witness ...")
	err = operations.WriteProof(proof, filepath.Join(dataDir, fmt.Sprintf("recursive_%v_%v.proof", beignIndex, endIndex)))
	if err != nil {
		panic(err)
	}

	err = operations.WriteWitness(pubWitness, filepath.Join(dataDir, fmt.Sprintf("recursive_%v_%v.wtns", beignIndex, endIndex)))
	if err != nil {
		panic(err)
	}
}
