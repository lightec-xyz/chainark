This is a simple example showing case how to use the `chainark` library.

## Understanding the data and the chain structure
Suppose we have a chain structureï¼š

`data0 <- data1 <- data2 <- data3`

Following the rule:

$id_{n+1}$ = SHA256($id_n$ || "chainark example")

Each data is simply composed by below two elements concatenated together `hash || string_literal`, where:

1. `hash` is hash value of 32 bytes, which is the SHA256 hash of its predecessor data;
2. `string literal` is `chainark example`.

Now the `LinkageID` is the `hash` value. In the supplied file `data.txt`, the first `hash` is generated by running this command:

`echo 0000000000000000000000000000000000000000000000000000000000000000 | xxd -r -p | openssl sha256 -hex`

It outputs hash value `66687aadf862bd776c8fc18b8e9f8e20089714856ee233b3902a591d0d5f2925`.

Then `data0`, or the first line of `data.txt` is simply

`66687aadf862bd776c8fc18b8e9f8e20089714856ee233b3902a591d0d5f2925636861696e61726b206578616d706c650a`

with `636861696e61726b206578616d706c650a` as the hex encode of `chainark example`.

Going forward we may have the ID corresponding to `data0` from running the command:

`echo 66687aadf862bd776c8fc18b8e9f8e20089714856ee233b3902a591d0d5f2925636861696e61726b206578616d706c650a | xxd -r -p | openssl sha256 -hex`

and its value is `18c4c25dc847bbc76fd3ca67fc4c2028dee5263fddcf01de3faddc20f0462d8f`. This is then the `genesis ID` or `id0`. Usually a genesis ID is publically known and recognized. 

Now `data1` becomes `18c4c25dc847bbc76fd3ca67fc4c2028dee5263fddcf01de3faddc20f0462d8f636861696e61726b206578616d706c650a`, and we can compute `id1`, and so on.

## The proving task

Now we want to prove that following the above hashing computation rule, a hash value of `d9d88c7cd8d017cbd9bddb18d2685a234d41b5c74ce3f6e32cb79dd9d6b70a84` could be computed starting from the data identified by the `genesis ID` of `18c4c25dc847bbc76fd3ca67fc4c2028dee5263fddcf01de3faddc20f0462d8f`. 

To do this, we first need to generate all the `unit` proofs, that is, we need a ZK-proof from a data item (`hash || "chainark example"`) to an ID (`hash`) for all the IDs from genesis to the one under question. `Unit` circuit is implemented in the `unit_circuit.go`. Besides unit circuit definition, it also needs to implement `UnitCircuitPublicAssignment` and a main function to output the unit proofs.

Then we also need to impelment `GenesisOrRecursiveCircuitPublicAssignment`, and created main functions to output the genesis and recursive proofs. The genesis circuit verifies two unit proofs. The recursive circuit verifies first a genesis proof or a recursive proof, then a unit proof. The proof generated from the recursive circuit could be used to verify the existence of a chain from the genesis data to the one under question.